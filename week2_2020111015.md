# Week 2, Lecture 1:
## Summary:-
Today's lecture was a detailed discussion on finding the nth fibonacci number, finding an optimum solution for the above problem and optimizing the solution. Afterwards we found karatsuba's multiplication method to speed up the multiplication method and further discussed how this wasnt the fastest known method.
## Detailed explanation:
When an Algorithm is proposed there are 3 important things to consider:
1. Correctness -> if the algorithm performs the desired task correctly for all test cases
2. Time Complexity -> The time it takes to perform the given tast, the lesser the time taken the more desirable the algorithm.
3. _Can we do better ?_ -> This is an important question to ask, unless a formal proof is given, it is assumed that a better (faster and more efficient in terms of storage) solution is always possible

### Finding the nth Fibonacci number
- Naive Approach:
  - We use a recursive function based on the definition of fibonacci numbers, the correctness is obvious. 
    ``` python
    function fib(n)
      if n = 0: return 0
      if n = 1: return 1
      else: return fib(n-1) + fib(n-2)
    ```
  - We might face memory issues if the run time stack isn't big enough for all the recursive call
  - The time complexity is found using the relation:
  
     `T(n) = T(n-1) + T(n-2) + 3`
     
     `F_n <= T(n)`
     
     `F_n is approx 2^0.694n`
   
  - So Time complexity is exponential and hence we will look for a better solution.

- Iterative approach:
  - Removes overlapping iterations.
    ``` python
    function fib(n)
    if n = 0 return 0
    array f[0 ... n]
    f[0] = 0, f[1] = 1
    for i = 2...n:
      f[i] = f[i-1] + f[i-2]
    return f[n]
    ```
  - The above code appears to have linear time complexity however addition of           arbitrarily large numbers is not a single step procedure
  - Fn is 0.694 bits, hence addition will have complexity )(n)
  - overall run time comes out to be O(N^2) which is much better but still slow.
 
 - Algorithm 3
  - We only need Fn and not the rest of the numbers
  - Hence we seek to compute Fn without computing Fi for all 1 <= i < n
  - <img src="https://latex.codecogs.com/gif.latex?\begin{pmatrix}&space;F_n\\&space;F_{n&plus;1}\\&space;\end{pmatrix}&space;=&space;\begin{pmatrix}&space;0&space;&&space;1\\&space;1&&space;0&space;\end{pmatrix}&space;\begin{pmatrix}&space;F_0\\&space;F_{1}\\&space;\end{pmatrix}" title="\begin{pmatrix} F_n\\ F_{n+1}\\ \end{pmatrix} = \begin{pmatrix} 0 & 1\\ 1& 0 \end{pmatrix} \begin{pmatrix} F_0\\ F_{1}\\ \end{pmatrix}"/>

